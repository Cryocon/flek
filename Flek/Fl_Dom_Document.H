/*
  This is the beginnings of "Flek Dom", the Flek Document Object Model.
  It will be based on libxml, but it's not in a useable state, yet.
*/

class Fl_Dom_Node
{
public:
  Fl_Dom_Node (Fl_Dom_Document *owner, NodeType type);

  enum {
    ELEMENT_NODE                = 1,
    ATTRIBUTE_NODE              = 2,
    TEXT_NODE                   = 3,
    CDATA_SECTION_NODE          = 4,
    ENTITY_REFERENCE_NODE       = 5,
    ENTITY_NODE                 = 6,
    PROCESSING_INSTRUCTION_NODE = 7,
    COMMENT_NODE                = 8,
    DOCUMENT_NODE               = 9,
    DOCUMENT_TYPE_NODE          = 10,
    DOCUMENT_FRAGMENT_NODE      = 11,
    NOTATION_NODE               = 12
  } NodeType;

  /**
   * The name of this node.
   */
  char * name ();
  /**
   * The value of this node.
   */
  char * value ();
  /**
   * The type of node.
   */
  NodeType type ();
  /**
   * The parent of this node. <code>Attr</code>, <code>Document</code>, 
   * <code>DocumentFragment</code>, <code>Entity</code>, and 
   * <code>Notation</code> may not have a parent.  If the node is not
   * attached to a tree this value is <code>null</code>.
   */
  Fl_Dom_Node * parent ();
  /**
   * The first child of this node.  If there are no children, this
   * returns <code>null</code>.
   */
  Fl_Dom_Node * first_child ();
  /**
   * The last child of this node.  If there are no children this 
   * returns <code>null</code>.
   */
  Fl_Dom_Node * last_child ();
  /** 
   * The node immediately following this one (the next sibling).
   * If there is no next node, then this returns <code>null</code>.
   */
  Fl_Dom_Node * next ();
  /** 
   * The node immediately preceding this one (the previous sibling).
   * If there is no previous node, then this returns <code>null</code>.
   */
  Fl_Dom_Node * previous ();
  /**
   * If this node is of type ELEMENT_NODE, then this returns a list of
   * it's attributes, or <code>null</code> otherwise.
   */
  Fl_Dom_NamedNodeMap * attributes ();
  /**
   * The <code>Fl_Dom_Document</code> associated with this node.  New
   * nodes will use this <code>Fl_Dom_Document</code> object.
   */
  Fl_Dom_Document * document ();
  /**
   * Inserts the node <code>newChild</code> before the existing child node 
   * <code>refChild</code>. If <code>refChild</code> is <code>null</code>, 
   * insert <code>newChild</code> at the end of the list of children.
   * <br>If <code>newChild</code> is a <code>DocumentFragment</code> object, 
   * all of its children are inserted, in the same order, before 
   * <code>refChild</code>. If the <code>newChild</code> is already in the 
   * tree, it is first removed.
   * @param newChild The node to insert.
   * @param refChild The reference node
   */
  Fl_Dom_Node * insert_before (Fl_Dom_Node *newChild, 
			     Fl_Dom_Node *refChild);
  /**
   * Replaces the child node <code>oldChild</code> with <code>newChild</code>
   *  in the list of children, and returns the <code>oldChild</code> node.
   * <br>If <code>newChild</code> is a <code>DocumentFragment</code> object, 
   * <code>refChild</code> is replaced by all of the 
   * <code>DocumentFragment</code> children, which are inserted in the same 
   * order. If the <code>newChild</code> is already in the tree, it is 
   * first removed.
   * @param newChild The new node to put in the child list.
   * @param oldChild The node being replaced in the list.
   */
  Fl_Dom_Node * replace_child (Fl_Dom_Node *newChild, 
			     Fl_Dom_Node *refChild);
  /**
   * Removes the child node indicated by <code>oldChild</code> from the list 
   * of children, and returns it.
   * @param oldChild The node being removed.
   * @return The node removed.
   */
  Fl_Dom_Node * remove (Fl_Dom_Node * oldChild);
  /**
   * Adds the node <code>newChild</code> to the end of the list of children 
   * of this node. If the <code>newChild</code> is already in the tree, it 
   * is first removed.
   * @param newChild The node to add.If it is a  
   *   <code>DocumentFragment</code> object, the entire contents of the 
   *   document fragment are moved into the child list of this node
   * @return The node added.
   */
  Fl_Dom_Node * append (Fl_Dom_Node * newChild);
  /**
   * This is a convenience method to allow easy determination of whether a 
   * node has any children.
   * @return  <code>true</code> if the node has any children, 
   *   <code>false</code> if the node has no children.
   */
  boolean has_children ();
  /**
   * Returns a duplicate of this node, i.e., serves as a generic copy 
   * constructor for nodes. The duplicate node has no parent (
   * <code>parentNode</code> returns <code>null</code>.).
   * <br>Cloning an <code>Element</code> copies all attributes and their 
   * values, including those generated by the XML processor to represent 
   * defaulted attributes, but this method does not copy any text it 
   * contains unless it is a deep clone, since the text is contained in a 
   * child <code>Text</code> node. Cloning any other type of node simply 
   * returns a copy of this node.
   * <br>Note that cloning an immutable subtree results in a mutable copy, 
   * but the children of an <code>EntityReference</code> clone are readonly.
   * @param deep If <code>true</code>, recursively clone the subtree under 
   *   the specified node; if <code>false</code>, clone only the node 
   *   itself (and its attributes, if it is an <code>Element</code>).  
   * @return The duplicate node.
   */
  Fl_Dom_Node * clone (boolean deep);
  /**
   * Tests whether the DOM implementation implements a specific feature and 
   * that feature is supported by this node.
   * @since DOM Level 2
   * @param feature The string of the feature to test. This is the same name 
   *   that which can be passed to the method <code>hasFeature</code> on 
   *   <code>DOMImplementation</code>.
   * @param version This is the version number of the feature to test. In 
   *   Level 2, version 1, this is the string "2.0". If the version is not 
   *   specified, supporting any version of the feature will cause the 
   *   method to return <code>true</code>.
   * @return Returns <code>true</code> if the specified feature is supported 
   *   on this node, <code>false</code> otherwise.
   */
  boolean supports (char * feature, 
		    char * version);
  /**
   * The namespace URI of this node, or <code>null</code> if it is 
   * unspecified.
   * <br>This is not a computed value that is the result of a namespace 
   * lookup based on an examination of the namespace declarations in scope. 
   * It is merely the namespace URI given at creation time.
   * <br>For nodes of any type other than <code>ELEMENT_NODE</code> and 
   * <code>ATTRIBUTE_NODE</code> and nodes created with a DOM Level 1 
   * method, such as <code>createElement</code> from the 
   * <code>Document</code> interface, this is always <code>null</code>.Per 
   * the Namespaces in XML Specification  an attribute does not inherit its 
   * namespace from the element it is attached to. If an attribute is not 
   * explicitly given a namespace, it simply has no namespace.
   */
  char * namespace_uri ();
  /**
   * The namespace prefix of this node, or <code>null</code> if it is 
   * unspecified.
   * <br>Note that setting this attribute, when permitted, changes the 
   * <code>nodeName</code> attribute, which holds the qualified name, as 
   * well as the <code>tagName</code> and <code>name</code> attributes of 
   * the <code>Element</code> and <code>Attr</code> interfaces, when 
   * applicable.
   * <br>Note also that changing the prefix of an attribute, that is known to
   *  have a default value, does not make a new attribute with the default 
   * value and the original prefix appear, since the 
   * <code>namespaceURI</code> and <code>localName</code> do not change.
   * @since DOM Level 2
   */
  char * prefix ();
  void prefix (char *prefix);
  /**
   * Returns the local part of the qualified name of this node.
   * <br>For nodes created with a DOM Level 1 method, such as 
   * <code>createElement</code> from the <code>Document</code> interface, 
   * it is <code>null</code>.
   * @since DOM Level 2
   */
  char * local_name ();
  boolean is_read_only ();
  void make_read_only ();
  
protected:
  Fl_Dom_Document *        Owner;
  Fl_Dom_Node *            Parent;
  boolean                ReadOnly;
  NodeType               Type;

  // children :
  Fl_Dom_Node              Children [];
  int                    ChildrenCount;

  // event registration :
  Fl_Dom_Listener          Listeners [];
  int                    ListenersCount;

};




class Fl_Dom_Document : public Fl_Dom_Node
{
public:
  

private:
  boolean      checkingCharacters;



};

Fl_Dom_Node::Fl_Dom_Node (Fl_Dom_Document *owner, NodeType type)
{
  Type = type;
  
  if (!owner)
    {
      if (type != DOCUMENT_NODE && type != DOCUMENT_TYPE_NODE)
	error ("no owner!");
    }
  Owner = owner;
  Parent = parent;
  ChildrenCount = 0;
  ListenersCount = 0;
  ReadOnly = 0;
}

NodeType 
Fl_Dom_Node::type ()
{
  return Type;
}

Fl_Dom_Node * 
Fl_Dom_Node::first_child ()
{
  return item (0);
}

Fl_Dom_Node *
Fl_Dom_Node::last_child ()
{
  return item (ChildrenCount - 1);
}

boolean
Fl_Dom_Node::has_children ()
{
  return (ChildrenCount > 0);
}

boolean 
Fl_Dom_Node::is_read_only ()
{
  return ReadOnly;
}

void
Fl_Dom_Node::make_read_only ()
{
  ReadOnly = 1;
  for (int i = 0; i < ChildrenCount; i++)
    Children [i].make_read_only ();
}

int 
Fl_Dom_Node::check (Fl_Dom_Node * child)
{
  if (ReadOnly)
    return NO_MODIFICATION_ALLOWED_ERR;
  if 

}
