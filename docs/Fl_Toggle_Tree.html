<HTML>
  <BODY bgcolor="white">
    <HR break>
    <H2><A name="Fl_Toggle_Tree">class Fl_Toggle_Tree</A></H2>
    <HR>
    <H3>Class Hierarchy</H3>
    <UL>
<PRE>
<A href="Fl_Toggle_Tree_Base.html#Fl_Toggle_Tree_Base">Fl_Toggle_Tree_Base</A>
   |
   +----<B>Fl_Toggle_Tree</B>
</PRE>
    </UL>
    <H3>Include Files</H3>
    <UL>
<PRE>
#include &lt;Flek/Fl_Toggle_Tree.H&gt;
</PRE>
    </UL>

    <H3>Description</H3>
    Fl_Toggle_Tree is a tree widget that allows branch visibility to be
    toggled on and off, similar to a collapsible list widget that is found
    in most widget tool kits.
    
    
    <P>
    <H3>Methods</H3>
    <CENTER>
      <TABLE width="90%">
	<TR><TD align=left valign=top>
	    <LI><A href="#Fl_Toggle_Tree.Fl_Toggle_Tree">Fl_Toggle_Tree</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.add_next">add_next</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.add_sub">add_sub</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.close">close</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.closed_pixmap">closed_pixmap</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.column_char">column_char</A></LI>
	  </TD><TD align=left valign=top>
	    <LI><A href="#Fl_Toggle_Tree.column_widths">column_widths</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.current">current</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.end_edit">end_edit</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.find">find</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.handle">handle</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.indent_toggles">indent_toggles</A></LI>
	  </TD><TD align=left valign=top>
	    <LI><A href="#Fl_Toggle_Tree.label_offset">label_offset</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.open">open</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.opened_pixmap">opened_pixmap</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.pixmap_offset">pixmap_offset</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.remove">remove</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.selected">selected</A></LI>
	  </TD><TD align=left valign=top>
	    <LI><A href="#Fl_Toggle_Tree.selection">selection</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.select_range">select_range</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.state">state</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.textfont">textfont</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.textsize">textsize</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.textcolor">textcolor</A></LI>
	  </TD><TD align=left valign=top>
	    <LI><A href="#Fl_Toggle_Tree.color">color</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.alternate_color">alternate_color</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.trim_color">trim_color</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.selection_color">selection_color</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.selection_label_color">selection_label_color</A></LI>
	  </TD><TD align=left valign=top>
	    <LI><A href="#Fl_Toggle_Tree.draw_lines">draw_lines</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.traverse_start">traverse_start</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.traverse_forward">traverse_forward</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.traverse_up">traverse_up</A></LI>
	    <LI><A href="#Fl_Toggle_Tree.unselect">unselect</A></LI>
	  </TD>
	</TR>
      </TABLE>
    </CENTER>


    <H4><A name="Fl_Toggle_Tree.Fl_Toggle_Tree">Fl_Toggle_Tree::Fl_Toggle_Tree(int x, int y, int w, int h)</A></H4>
    <blockquote>
      The constructor makes an empty Fl_Toggle_Tree.
    </blockquote>
      
    <H4><A name="Fl_Toggle_Tree.add_next">void Fl_Toggle_Tree::add_next(Fl_Toggle_Node_Base *n)<BR>
    <blockquote>
      Fl_Toggle_Node * Fl_Toggle_Tree::add_next(char* label=0, int can_open=1, Fl_Pixmap* pixmap=0, void * d=0)</A></H4>
      <P>The first form inserts n as the next item after the current node.  If 
	the tree is empty, then n becomes the first node of the toggle tree.
      <P>The second form is equivalent to <TT>add_next(new Fl_Toggle_Node(label, 
	  can_open, pixmap, d))</TT>.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.add_sub">void Fl_Toggle_Tree::add_sub(Fl_Toggle_Node_Base *n)<BR>
    <blockquote>
      Fl_Toggle_Node * Fl_Toggle_Tree::add_sub(char* label=0, int can_open=1, Fl_Pixmap* pixmap=0, void * d=0)</A></H4>
      <P>The first form inserts n as the next sub item after the current node.  
	If the tree is empty, then n becomes the first node of the toggle tree.
      <P>The second form is equivalent to <TT>add_sub(new Fl_Toggle_Node(label, 
	  can_open, pixmap, d))</TT>.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.close">void Fl_Toggle_Tree::close(Fl_Toggle_Node_Base *n)</A></H4>
    <blockquote>
      <P>Close node n.  This hides any sub items belonging to n.
    </blockquote>
    
    
    <H4><A name="Fl_Toggle_Tree.closed_pixmap">Fl_Pixmap * Fl_Toggle_Tree::close_pixmap()<BR>
    <blockquote>
      void Fl_Toggle_Tree::close_pixmap(Fl_Pixmap *p)</A></H4>
      Get or set the pixmap that is drawn when a node is "closed".
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.column_char">char Fl_Toggle_Tree::column_char()<BR>
	void Fl_Toggle_Tree::column_char(char d)</A></H4>
    <blockquote>
      <P>The first form gets the current column separator character. By default 
	this is '\t' (tab). 
      <P>The second form sets the column separator to c. This will only have an 
	effect if you also set column_widths(). 
    </blockquote>
    
    
    <H4><A name="Fl_Toggle_Tree.column_widths">const int * Fl_Toggle_Tree::column_widths()<BR>
	void Fl_Toggle_Tree::column_widths(const int* l)</A></H4>
    <blockquote>
      <P>The first form gets the current column width array. This array is 
	zero-terminated and specifies the widths in pixels of each column. 
	The text is split at each column_char() and each part is formatted 
	into it's own column. After the last column any remaining text is 
	formatted into the space between the last column and the right edge 
	of the Fl_Toggle_Tree wdiget, even if the text contains instances of 
	column_char() . The default value is a one-element array of just a
	zero, which makes there are no columns. 
      <P>The second form sets the current array to w. Make sure the last 
	entry is zero. 
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.current">Fl_Toggle_Node * Fl_Toggle_Tree::current()</H4>
    <blockquote>
      <P>Returns the current node (as set with the traversal functions).
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.edit_callback">void Fl_Toggle_Tree::edit_callback(Fl_Callback* c, void* p)<br>
	void Fl_Toggle_Tree::edit_callback(Fl_Callback* c)
	void Fl_Toggle_Tree::edit_callback(Fl_Callback0* c)
	void Fl_Toggle_Tree::edit_callback(Fl_Callback1* c, void* p)</a></H4>
    <blockquote>
      <P>Set the edit callback.  A user defined callback should be sure to call <TT>end_edit()</TT>.
    </blockquote>
    
    
    <H4><A name="Fl_Toggle_Tree.end_edit">void Fl_Toggle_Tree::end_edit()</H4>
    <blockquote>
      <P>Stop editing the current node.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.find">Fl_Toggle_Node * Fl_Toggle_Tree::find(void *d)<BR>
	Fl_Toggle_Node * Fl_Toggle_Tree::find(char *c)</A></H4>
    <blockquote>
      <P>The first form finds the first node in the tree that matches the string c.
	If no node matches c, then find returns 0.
      <P>The second form finds the first node in the tree whose data pointer 
	is equal to the pointer d.  If no node matches d, then find returns 0.
    </blockquote>
    
    
    <H4><A name="Fl_Toggle_Tree.handle">void Fl_Toggle_Tree::handle()</A></H4>
    <blockquote>
      <P>To change how Fl_Toggle_Tree <a href="subclassing.html">handles</a> 
	events passed to it, you can subclass Fl_Toggle_Tree and override the 
	handle function.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.indent_toggles">void Fl_Toggle_Tree::indent_toggles(int b)<BR>
	int Fl_Toggle_Tree::indent_toggles()</A></H4>
    <blockquote>
      <P>Gets or sets if toggled items are indented or not.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.draw_lines">void Fl_Toggle_Tree::draw_lines(int b)<BR>
	int Fl_Toggle_Tree::draw_lines()</A></H4>
    <blockquote>
      <P>Gets or sets if lines are drawn between toggle nodes.
    </blockquote>
    
    
    <H4><A name="Fl_Toggle_Tree.label_offset">void Fl_Toggle_Tree::label_offset(int x)</A></H4>
    <blockquote>
      <P>Set the horizontal label offset to x pixels.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.open">void Fl_Toggle_Tree::open(Fl_Toggle_Node_Base *n)</A></H4>
    <blockquote>
      <P>Open node n.  This reveals any sub items belonging to n.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.opened_pixmap">Fl_Pixmap * Fl_Toggle_Tree::opened_pixmap()<BR>
	void Fl_Toggle_Tree::opened_pixmap(Fl_Pixmap *p)</A></H4>
    <blockquote>
      <P>Get or set the pixmap displayed when a node is "open".
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.pixmap_offset">void Fl_Toggle_Tree::pixmap_offset(int x)</A></H4>
    <blockquote>
      <P>Set the horizontal pixmap offset to x pixels.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.remove">int Fl_Toggle_Tree::remove(Fl_Toggle_Node *n)<BR>
	int Fl_Toggle_Tree::remove(void *d)<BR>
	int Fl_Toggle_Tree::remove(char *c)</A></H4>
    <blockquote>
      <P>The first form removes n (and all of it's sub nodes) from the tree.  
	If successful remove returns 1, otherwise it returns 0.
      <P>The second form performs a <TT>find()</TT> with d as it's argument
	and <TT>remove()</TT>s the returned node if it exists.
      <P>The third form performs a <TT>find()</TT> with the string c as it's 
	argument and <TT>remove()</TT>s the returned node if it exists.
    </blockquote>
    
    
    <H4><A name="Fl_Toggle_Tree.selected">Fl_Toggle_Node * Fl_Toggle_Tree::selected()</A></H4>
    <blockquote>
      <P>Return the selected node.  If multiple nodes are selected, then 
	<TT>selected()</TT> returns 0, and <TT>selection()</TT> should be 
	checked.  Note that the <TT>current()</TT> node is <b>not</b> 
	necessarily equal to the <TT>selected()</TT> node.  Fl_Toggle_Tree
	attempts to maintain the selected item even while the tree is
	being modified.  Of course, if the node is unselected or deleted by
	some operation, <TT>selected()</TT> will return 0.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.selection">Fl_Toggle_Node * Fl_Toggle_Tree::selection()<BR>
	Fl_Toggle_Node * Fl_Toggle_Tree::selection(int i)</A></H4>
    <blockquote>
      <P>The first form traverses forward and returns the next selected node.
      <p>The second form returns the i-th selected node.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.select_range">void Fl_Toggle_Tree::select_range(Fl_Toggle_Node* start, Fl_Toggle_Node* end, int add=0)</A></H4>
    <blockquote>
      <P>Sets nodes between start and end as selected.  add..
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.state">Fl_Toggle_Node * Fl_Toggle_Tree::state()</A></H4>
    <blockquote>
      <P>Returns the state of the Fl_Toggle_Tree widget.  Enumerated states include:   FL_TOGGLE_NONE = 0,
	FL_TOGGLE_SELECT = 1,  FL_TOGGLE_RESELECT = 2,  FL_TOGGLE_SELECT_MASK = 3, FL_TOGGLE_OPENED = 4,
	FL_TOGGLE_CLOSED = 8,  FL_TOGGLE_HIT = 16,
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.textfont">Fl_Font Fl_Toggle_Tree::textfont()<BR>
	void Fl_Toggle_Tree::textfont(Fl_Font d)</A></H4>
    <blockquote>
      <P>The first form gets the default text font for the lines in the browser.
      <P>The second form sets the default text font to font
    </blockquote>
    
    
    <H4><A name="Fl_Toggle_Tree.textsize">uchar Fl_Toggle_Tree::textsize()<BR>
	void Fl_Toggle_Tree::textsize(uchar d)</A></H4>
    <blockquote>
      <P>The first form gets the default text size for the lines in the browser.
      <P>The second form sets the default text size to size.
    </blockquote>
    
    
    <H4><A name="Fl_Toggle_Tree.textcolor">uchar Fl_Toggle_Tree::textcolor()<BR>
	void Fl_Toggle_Tree::textcolor(uchar d)</A></H4>
    <blockquote>
      <P>The first form gets the default text color for the lines in the browser. 
      <P>The second form sets the default text color to color
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.color">uchar Fl_Toggle_Tree::color()<BR>
	void Fl_Toggle_Tree::color(uchar d)</A></H4>
    <blockquote>
      <P>The first form gets the default background color for the lines in the browser. 
      <P>The second form sets the default background color to color 
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.alternate_color">uchar Fl_Toggle_Tree::alternate_color()<BR>
	void Fl_Toggle_Tree::alternate_color(uchar d)</A></H4>
    <blockquote>
      <P>The first form gets the alternating background color for the lines in the browser. 
      <P>The second form sets the alternating background color to color 
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.trim_color">uchar Fl_Toggle_Tree::trim_color()<BR>
	void Fl_Toggle_Tree::trim_color(uchar d)</A></H4>
    <blockquote>
    <P>The first form gets the trim color that seperates lines of text in the browser.
      <P>The second form sets the trim color.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.selection_color">uchar Fl_Toggle_Tree::selection_color()<BR>
	void Fl_Toggle_Tree::selection_color(uchar d)</A></H4>
    <blockquote>
      <P>The first form gets the selection background color for the lines in the browser. 
      <P>The second form sets the selection background color to color 
    </blockquote>

    <H4><A name="Fl_Toggle_Tree.selection_label_color">uchar Fl_Toggle_Tree::selection_label_color()<BR>
	void Fl_Toggle_Tree::selection_label_color(uchar d)</A></H4>
    <blockquote>
      <P>The first form gets the selection text color for the lines in the browser. 
      <P>The second form sets the selection text color to color 
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.traverse_start">void Fl_Toggle_Tree::traverse_start(Fl_Toggle_Node_Base* t)<BR>
	Fl_Toggle_Node* Fl_Toggle_Tree::traverse_start()</A></H4>
    <blockquote>
      <P>The first form of this method sets the current pointer to t.  The second
	form of this method, sets the traversal pointer to <TT>first()</TT> and
	then returns first().  The second form is provided for convenience.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.traverse_forward">Fl_Toggle_Node* Fl_Toggle_Tree::traverse_forward(int visible, int &depth)<BR>
	Fl_Toggle_Node* Fl_Toggle_Tree::traverse_forward()</A></H4>
<blockquote>
      <P>This method traverses forward through the tree.  Traversal through 
	the node tree is done by a depth first traversal that updates the 
	current node pointer.  If traverse_forward returns 0, then the 
	current node pointer has reached the end of the tree.  Otherwise, 
	traverse_forward returns the next node in the tree.
      <P>The visible flag should be set to 1 if you want to restrict 
	traversal to the visible tree (the Fl_Toggle_Node_Bases that are not closed).  The 
	depth variable is updated with the new node depth, if the old node depth 
	is passed to traverse_forward.
      <P>The second form of the method is the same as 
      <TT>traverse_forward(0, temp)</TT>.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.traverse_up">Fl_Toggle_Node_Base* Fl_Toggle_Tree::traverse_up()</A></H4>
    <blockquote>
      <P>If the current node has an up pointer, traverse_up returns this 
	pointer and sets it as the current node.
    </blockquote>
    
    <H4><A name="Fl_Toggle_Tree.unselect">void Fl_Toggle_Tree::unselect()</A></H4>
    <blockquote>
      <P>Unselects all selected items.
    </blockquote>
    
  </BODY>
</HTML>
